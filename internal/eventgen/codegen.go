package eventgen

import (
	"bytes"
	"fmt"
	"os/exec"
	"path/filepath"

	"github.com/dave/jennifer/jen"
)

const (
	commonsEventsImport  = "github.com/Sokol111/ecommerce-commons/pkg/messaging/kafka/events"
	commonsMappingImport = "github.com/Sokol111/ecommerce-commons/pkg/messaging/kafka/avro/mapping"
)

// generateGoTypes uses avrogen for payload types and jennifer for event wrappers.
func generateGoTypes(cfg *Config, payloads []*PayloadSchema) error {
	fmt.Println("Generating Go types...")

	// Step 1: Generate payload types with avrogen (from payload schemas directly)
	if err := generatePayloadTypes(cfg, payloads); err != nil {
		return err
	}

	// Step 2: Generate event wrappers with jennifer
	if err := generateEventWrappers(cfg, payloads); err != nil {
		return err
	}

	fmt.Println("  Created types.gen.go and events.gen.go")
	return nil
}

// generatePayloadTypes uses avrogen to generate payload structs from payload schemas.
func generatePayloadTypes(cfg *Config, payloads []*PayloadSchema) error {
	// Build list of payload schema files
	schemaFiles := make([]string, 0, len(payloads))
	for _, p := range payloads {
		schemaFiles = append(schemaFiles, p.FilePath)
	}

	outputFile := filepath.Join(cfg.OutputDir, "types.gen.go")
	args := []string{
		"-pkg", cfg.Package,
		"-o", outputFile,
		"-tags", "json:snake",
	}
	args = append(args, schemaFiles...)

	cmd := exec.Command("avrogen", args...)
	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("avrogen failed: %w\n%s", err, stderr.String())
	}

	return nil
}

// generateEventWrappers generates event envelope structs using jennifer.
func generateEventWrappers(cfg *Config, payloads []*PayloadSchema) error {
	f := jen.NewFile(cfg.Package)
	f.HeaderComment("Code generated by eventgen. DO NOT EDIT.")

	for _, p := range payloads {
		// Event struct with commons.EventMetadata
		f.Commentf("%s is the event envelope for %s.", p.EventTypeName(), p.EventName())
		f.Type().Id(p.EventTypeName()).Struct(
			jen.Id("Metadata").Qual(commonsEventsImport, "EventMetadata").Tag(map[string]string{
				"avro": "metadata",
				"json": "metadata",
			}),
			jen.Id("Payload").Id(p.PayloadTypeName()).Tag(map[string]string{
				"avro": "payload",
				"json": "payload",
			}),
		)
		f.Line()

		// GetMetadata method for Event interface
		f.Func().
			Params(jen.Id("e").Op("*").Id(p.EventTypeName())).
			Id("GetMetadata").
			Params().
			Op("*").Qual(commonsEventsImport, "EventMetadata").
			Block(jen.Return(jen.Op("&").Id("e").Dot("Metadata")))
		f.Line()
	}

	outputFile := filepath.Join(cfg.OutputDir, "events.gen.go")
	return f.Save(outputFile)
}

// generateConstants generates the constants.gen.go file using jennifer.
func generateConstants(cfg *Config, payloads []*PayloadSchema) error {
	fmt.Println("Generating constants...")

	f := jen.NewFile(cfg.Package)
	f.HeaderComment("Code generated by eventgen. DO NOT EDIT.")

	// Import for reflect and mapping
	f.ImportName("reflect", "reflect")
	f.ImportName(commonsMappingImport, "mapping")

	// Event type constants
	f.Comment("Event type constants - match Avro schema names")
	f.Const().DefsFunc(func(group *jen.Group) {
		for _, p := range payloads {
			group.Id("EventType" + p.EventName()).Op("=").Lit(p.EventTypeName())
		}
	})
	f.Line()

	// Collect unique topics
	topicSet := make(map[string]bool)
	for _, p := range payloads {
		if p.Topic != "" {
			topicSet[p.Topic] = true
		}
	}

	// Topic constants (if topics exist)
	if len(topicSet) > 0 {
		// Sort topics for consistent output
		topics := make([]string, 0, len(topicSet))
		for topic := range topicSet {
			topics = append(topics, topic)
		}

		f.Comment("Topic constants - Kafka topics from Avro schemas")
		f.Const().DefsFunc(func(group *jen.Group) {
			for _, topic := range topics {
				group.Id(TopicToConstName(topic)).Op("=").Lit(topic)
			}
		})
		f.Line()
	}

	// Schema name constants
	f.Comment("Schema name constants - Avro schema full names (namespace.name)")
	f.Const().DefsFunc(func(group *jen.Group) {
		for _, p := range payloads {
			group.Id("SchemaName" + p.EventName()).Op("=").Lit(p.SchemaFullName())
		}
	})
	f.Line()

	// SchemaBindings slice
	f.Comment("SchemaBindings contains all event schema bindings for registration with TypeMapping.")
	f.Comment("Use this to register all schemas in your microservice:")
	f.Comment("")
	f.Comment("\ttypeMapping.RegisterBindings(events.SchemaBindings)")
	f.Var().Id("SchemaBindings").Op("=").Index().Qual(commonsMappingImport, "SchemaBinding").ValuesFunc(func(group *jen.Group) {
		for _, p := range payloads {
			var topicStmt *jen.Statement
			if p.Topic != "" {
				topicStmt = jen.Id(TopicToConstName(p.Topic))
			} else {
				topicStmt = jen.Lit("")
			}
			group.Values(jen.Dict{
				jen.Id("GoType"):     jen.Qual("reflect", "TypeOf").Call(jen.Id(p.EventTypeName()).Values()),
				jen.Id("SchemaJSON"): jen.Id(p.EventName() + "Schema"),
				jen.Id("SchemaName"): jen.Id("SchemaName" + p.EventName()),
				jen.Id("Topic"):      topicStmt,
			})
		}
	})

	outputFile := filepath.Join(cfg.OutputDir, "constants.gen.go")
	if err := f.Save(outputFile); err != nil {
		return fmt.Errorf("failed to write constants: %w", err)
	}

	fmt.Println("  Created constants.gen.go")
	return nil
}

// generateSchemaEmbeddings generates the schemas.gen.go file using jennifer.
func generateSchemaEmbeddings(cfg *Config, payloads []*PayloadSchema) error {
	fmt.Println("Generating schema embeddings...")

	f := jen.NewFile(cfg.Package)
	f.HeaderComment("Code generated by eventgen. DO NOT EDIT.")

	// Import embed
	f.ImportName("embed", "_")
	f.Anon("embed")

	// Event schema embeddings
	f.Comment("Event schemas with EventMetadata inlined (ready for Avro serialization)")
	for _, p := range payloads {
		f.Comment(fmt.Sprintf("//go:embed schemas/%s.avsc", p.BaseName))
		f.Var().Id(p.EventName() + "Schema").Index().Byte()
		f.Line()
	}

	outputFile := filepath.Join(cfg.OutputDir, "schemas.gen.go")
	if err := f.Save(outputFile); err != nil {
		return fmt.Errorf("failed to write schemas: %w", err)
	}

	fmt.Println("  Created schemas.gen.go")
	return nil
}

// TopicToConstName converts a topic name to a Go constant name.
// e.g., "catalog.product.events" -> "TopicCatalogProductEvents"
func TopicToConstName(topic string) string {
	return "Topic" + toPascalCase(replaceDotsWithUnderscores(topic))
}

// replaceDotsWithUnderscores replaces dots with underscores for processing.
func replaceDotsWithUnderscores(s string) string {
	result := make([]byte, len(s))
	for i := 0; i < len(s); i++ {
		if s[i] == '.' {
			result[i] = '_'
		} else {
			result[i] = s[i]
		}
	}
	return string(result)
}
