package eventgen

import (
	"fmt"
	"path/filepath"
	"slices"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/ettle/strcase"
	"github.com/samber/lo"
)

const (
	commonsMappingImport = "github.com/Sokol111/ecommerce-commons/pkg/messaging/kafka/avro/mapping"
)

// GenerateConstants generates the constants.gen.go file using jennifer.
func GenerateConstants(cfg *Config, payloads []*AvroSchema) error {
	fmt.Println("Generating constants...")

	f := jen.NewFile(cfg.Package)
	f.HeaderComment("Code generated by eventgen. DO NOT EDIT.")

	// Import for reflect and mapping
	f.ImportName("reflect", "reflect")
	f.ImportName(commonsMappingImport, "mapping")

	// Event type constants
	f.Comment("Event type constants - match Avro schema names")
	f.Const().DefsFunc(func(group *jen.Group) {
		for _, p := range payloads {
			group.Id("EventType" + p.EventName()).Op("=").Lit(p.EventTypeName())
		}
	})
	f.Line()

	// Collect and sort unique topics
	topics := collectUniqueTopics(payloads)
	f.Comment("Topic constants - Kafka topics from Avro schemas")
	f.Const().DefsFunc(func(group *jen.Group) {
		for _, topic := range topics {
			group.Id(topicToConstName(topic)).Op("=").Lit(topic)
		}
	})
	f.Line()

	// Schema name constants
	f.Comment("Schema name constants - Avro schema full names (namespace.name)")
	f.Const().DefsFunc(func(group *jen.Group) {
		for _, p := range payloads {
			group.Id("SchemaName" + p.EventName()).Op("=").Lit(p.EventSchemaFullName())
		}
	})
	f.Line()

	// SchemaBindings slice
	f.Comment("SchemaBindings contains all event schema bindings for registration with TypeMapping.")
	f.Comment("Use this to register all schemas in your microservice:")
	f.Comment("")
	f.Comment("\ttypeMapping.RegisterBindings(events.SchemaBindings)")
	f.Var().Id("SchemaBindings").Op("=").Index().Qual(commonsMappingImport, "SchemaBinding").ValuesFunc(func(group *jen.Group) {
		for _, p := range payloads {
			group.Values(jen.Dict{
				jen.Id("GoType"):     jen.Qual("reflect", "TypeOf").Call(jen.Id(p.EventTypeName()).Values()),
				jen.Id("SchemaJSON"): jen.Id(p.EventName() + "Schema"),
				jen.Id("SchemaName"): jen.Id("SchemaName" + p.EventName()),
				jen.Id("Topic"):      jen.Id(topicToConstName(p.Topic)),
			})
		}
	})

	outputFile := filepath.Join(cfg.OutputDir, "constants.gen.go")
	if err := f.Save(outputFile); err != nil {
		return fmt.Errorf("failed to write constants: %w", err)
	}

	fmt.Println("  Created constants.gen.go")
	return nil
}

// collectUniqueTopics extracts and sorts unique topics from payloads.
func collectUniqueTopics(payloads []*AvroSchema) []string {
	topics := lo.Uniq(lo.Map(payloads, func(p *AvroSchema, _ int) string {
		return p.Topic
	}))
	slices.Sort(topics)
	return topics
}

// topicToConstName converts a topic name to a Go constant name,
// e.g., "catalog.product.events" -> "TopicCatalogProductEvents".
func topicToConstName(topic string) string {
	return "Topic" + strcase.ToPascal(strings.ReplaceAll(topic, ".", "_"))
}
