package eventgen

import (
	"fmt"
	"path/filepath"

	"github.com/dave/jennifer/jen"
	"github.com/ettle/strcase"
)

const (
	fxImport = "go.uber.org/fx"
)

// GenerateModule generates the module.gen.go file with fx module for event registration.
func GenerateModule(cfg *Config, payloads []*AvroSchema) error {
	fmt.Println("Generating fx module...")

	f := jen.NewFile(cfg.Package)
	f.HeaderComment("Code generated by eventgen. DO NOT EDIT.")

	// Import fx and events
	f.ImportName(fxImport, "fx")
	f.ImportName(commonsEventsImport, "events")

	// Generate module name from package name
	moduleName := strcase.ToKebab(cfg.Package) + "-events"

	// Module function
	f.Comment("Module provides event registration for dependency injection.")
	f.Comment("Include this module in your fx.App to automatically register all events.")
	f.Comment("")
	f.Comment("Usage:")
	f.Comment("  fx.New(")
	f.Commentf("      %s.Module(),", cfg.Package)
	f.Comment("      // ... other modules")
	f.Comment("  )")
	f.Func().Id("Module").Params().Qual(fxImport, "Option").Block(
		jen.Return(
			jen.Qual(fxImport, "Module").Call(
				jen.Lit(moduleName),
				jen.Qual(fxImport, "Invoke").Call(jen.Id("registerEvents")),
			),
		),
	)
	f.Line()

	// registerEvents function
	f.Func().Id("registerEvents").Params(
		jen.Id("registry").Qual(commonsEventsImport, "EventRegistry"),
	).BlockFunc(func(g *jen.Group) {
		for _, p := range payloads {
			g.Id("registry").Dot("Register").Call(
				jen.Id("SchemaName"+p.EventName()),
				jen.Func().Params().Qual(commonsEventsImport, "Event").Block(
					jen.Return(jen.Op("&").Id(p.EventTypeName()).Values()),
				),
			)
		}
	})

	outputFile := filepath.Join(cfg.OutputDir, "module.gen.go")
	if err := f.Save(outputFile); err != nil {
		return fmt.Errorf("failed to write module: %w", err)
	}

	fmt.Println("  Created module.gen.go")
	return nil
}
