package eventgen

import (
	"bytes"
	"fmt"
	"sort"
	"text/template"
)

// TemplateRenderer handles rendering of Go code templates.
type TemplateRenderer struct {
	config *Config
}

// NewTemplateRenderer creates a new template renderer.
func NewTemplateRenderer(cfg *Config) *TemplateRenderer {
	return &TemplateRenderer{config: cfg}
}

// RenderConstants renders the constants.gen.go file.
func (r *TemplateRenderer) RenderConstants(envelopes []*EnvelopeSchema, topics []*TopicInfo, asyncSpec *AsyncAPISpec, eventTopicMap map[string]string) ([]byte, error) {
	funcs := template.FuncMap{
		"topicConstName": TopicToConstName,
		"eventTopic": func(eventTypeName string) string {
			if topic, ok := eventTopicMap[eventTypeName]; ok {
				return TopicToConstName(topic)
			}
			// Fallback: try without "Event" suffix
			baseName := eventTypeName
			if len(baseName) > 5 && baseName[len(baseName)-5:] == "Event" {
				baseName = baseName[:len(baseName)-5]
			}
			if topic, ok := eventTopicMap[baseName]; ok {
				return TopicToConstName(topic)
			}
			return `""`
		},
	}

	tmpl, err := template.New("constants").Funcs(funcs).Parse(constantsTemplate)
	if err != nil {
		return nil, fmt.Errorf("failed to parse constants template: %w", err)
	}

	// Sort topics for consistent output
	if topics != nil {
		sort.Slice(topics, func(i, j int) bool {
			return topics[i].Name < topics[j].Name
		})
	}

	data := constantsData{
		Package:       r.config.Package,
		Envelopes:     envelopes,
		Topics:        topics,
		EventTopicMap: eventTopicMap,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("failed to execute constants template: %w", err)
	}

	return buf.Bytes(), nil
}

// RenderSchemas renders the schemas.gen.go file.
func (r *TemplateRenderer) RenderSchemas(envelopes []*EnvelopeSchema, hasAsyncAPI bool) ([]byte, error) {
	tmpl, err := template.New("schemas").Parse(schemasTemplate)
	if err != nil {
		return nil, fmt.Errorf("failed to parse schemas template: %w", err)
	}

	data := schemasData{
		Package:     r.config.Package,
		Envelopes:   envelopes,
		HasAsyncAPI: hasAsyncAPI,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("failed to execute schemas template: %w", err)
	}

	return buf.Bytes(), nil
}

// Template data structures

type constantsData struct {
	Package       string
	Envelopes     []*EnvelopeSchema
	Topics        []*TopicInfo
	EventTopicMap map[string]string
}

type schemasData struct {
	Package     string
	Envelopes   []*EnvelopeSchema
	HasAsyncAPI bool
}

// Template functions

func init() {
	// Register template functions
}

// Templates

const constantsTemplate = `// Code generated by eventgen. DO NOT EDIT.
package {{.Package}}

import (
	"reflect"

	"github.com/Sokol111/ecommerce-commons/pkg/messaging/kafka/avro/mapping"
)

// Event type constants - match Avro schema names
const (
{{- range .Envelopes}}
	EventType{{.Payload.EventName}} = "{{.Payload.EventTypeName}}"
{{- end}}
)

{{if .Topics}}
// Topic constants - Kafka topics from AsyncAPI spec
const (
{{- range .Topics}}
	{{topicConstName .Name}} = "{{.Name}}"
{{- end}}
)
{{end}}

// Schema name constants - Avro schema full names (namespace.name)
const (
{{- range .Envelopes}}
	SchemaName{{.Payload.EventName}} = "{{.Schema.FullName}}"
{{- end}}
)

// SchemaBindings contains all event schema bindings for registration with TypeMapping.
// Use this to register all schemas in your microservice:
//
//	typeMapping.RegisterBindings(events.SchemaBindings)
var SchemaBindings = []mapping.SchemaBinding{
{{- range .Envelopes}}
	{
		GoType:     reflect.TypeOf({{.Payload.EventTypeName}}{}),
		SchemaJSON: {{.Payload.EventName}}Schema,
		SchemaName: SchemaName{{.Payload.EventName}},
		Topic:      {{eventTopic .Payload.EventTypeName}},
	},
{{- end}}
}
`

const schemasTemplate = `// Code generated by eventgen. DO NOT EDIT.
package {{.Package}}

import _ "embed"

{{if .HasAsyncAPI}}
//go:embed asyncapi.yaml
var AsyncAPISpec []byte

{{end}}
// Event schemas with EventMetadata inlined (ready for Avro serialization)
{{range .Envelopes}}
//go:embed schemas/{{.Payload.BaseName}}.avsc
var {{.Payload.EventName}}Schema []byte

{{end}}
`
